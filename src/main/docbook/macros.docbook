<?xml version="1.0" encoding="utf-8"?>
<chapter version="5.0"
         xml:lang="en"
         xml:id="functions-as-representation"
         xreflabel="Functions as Representation"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xml="http://www.w3.org/XML/1998/namespace"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xsi:schemaLocation="http://docbook.org/ns/docbook
                             http://www.docbook.org/xml/5.0/xsd/docbook.xsd
                             http://www.w3.org/1999/xlink
                             http://www.docbook.org/xml/5.0/xsd/xlink.xsd
                             http://www.w3.org/XML/1998/namespace
                             http://www.docbook.org/xml/5.0/xsd/xml.xsd">
    <title>Macros</title>
    <para>
        Lisp's macro facility allows you to define operators that are
        implemented by transformation. The definition of a macro is
        essentially a function that generates Lisp code - a program that
        writes programs. From these small beginnings arise great
        possibilities, and also unexpected hazards. Chapters 7 - 10 form a
        tutorial on macros. This chapter explains how macros work, gives
        techniques for writing and testing them, and looks at the issue of
        macro style.
    </para>
    <section xml:id="how-macros-work" xreflabel="How Macros Work">
        <title>How Macros Work</title>
        <para>
            Since macros can be called and return values, they tend to be
            associated with functions. Macro definitions sometimes resemble
            function definitions, and speaking informally, people call do,
            which is actually a macro, a "built-in function." But pushing the
            analogy too far can be a source of confusion. Macros work
            differently from normal functions, and knowing how and why macros
            are different is the key to using them correctly. A function
            produces results, but a macro produces expressions - which, when
            evaluated, produce results.
        </para>
        <para>
            The best way to begin is to move straight into an example.
            Suppose we want to write a macro <function>nil!</function>,
            which sets its argument to <constant>nil</constant>. We want
            <code>(nil! x)</code>
            to have the same effect as
            <code>(setq x nil)</code>. We
            do it by defining
            <function>nil!</function>
            as a macro which turns instances of the
            first form into instances of the second.
        </para>
        <programlisting><![CDATA[
> (defmacro nil! (var)
(list 'setq var nil))
NIL!
82]]>
        </programlisting>
        <para>Paraphrased in English, this definition tells Lisp: "Whenever
            you see an expression of the form <code>(nil! var)</code>,
            turn it into one of the form <code>(setq var nil)</code>
            before evaluating it."
        </para>
        <para>
            The expression generated by the macro will be evaluated in place
            of the original macro call. A macro call is a list whose first
            element is the name of a macro. What happens when we type the macro
            call <code>(nil! x)</code>
            into the toplevel? Lisp notices that nil! is the name
            of a macro, and
        </para>
        <orderedlist>
            <listitem>
                <para>
                    builds the expression specified by the definition above, then
                </para>
            </listitem>
            <listitem>
                <para>
                    evaluates that expression in place of the original macro call.
                </para>
            </listitem>
        </orderedlist>
        <para>
            The step of building the new expression is called
            macroexpansion. Lisp looks up the definition of <function>nil!</function>,
            which shows
            how to construct a replacement for the macro call. The definition
            of nil! is applied like a function to the expressions given as
            arguments in the macro call. It returns a list of three elements:
            <function>setq</function>
            , the expression given as the argument
            to the macro, and nil.
            In this case, the argument to nil! is x, and the macroexpansion is
            <code>(setq x nil)</code>.
        </para>
        <para>
            After macroexpansion comes a second step, evaluation. Lisp
            evaluates the macroexpansion (setq x nil) as if you had typed that
            in the first place. Evaluation does not always come immediately
            after expansion, as it does at the toplevel. A macro call occurring
            in the definition of a function will be expanded when the function
            is compiled, but the expansion - or the object code which results
            from it - won't be evaluated until the function is called.
        </para>
        <para>
            Many of the difficulties you might encounter with macros can be
            avoided by maintaining a sharp distinction between macroexpansion
            and evaluation. When writing macros, know which computations are
            performed during macroexpansion, and which during evaluation, for
            the two steps generally operate on objects of two different sorts.
            The macroexpansion step deals with expressions, and the evaluation
            step deals with their values.
        </para>
        <para>
            Sometimes macroexpansioncan be more complicated than it was in
            the case of nil!. The expansion of nil! was a call to a built-in
            special form, but sometimes the expansion of a macro will be yet
            another macro call, like a Russian doll which contains another doll
            inside it. In such cases, macroexpansion simply continues until it
            arrives at an expression which is no longer a macro call. The
            process can take arbitrarily many steps, so long as it terminates
            eventually.
        </para>
        <para>
            Many languages offer some form of macro, but Lisp macros are
            singularly powerful. When a file of Lisp is compiled, a parser
            reads the source code and sends its output to the compiler. Here's
            the stroke of genius: the output of the parser consists of lists of
            Lisp objects. With macros, we can manipulate the program while it's
            in this intermediate form between parser and compiler. If
            necessary, these manipulations can be very extensive. A macro
            generating its expansion has at its disposition the full power of
            Lisp. Indeed, a macro is really a Lisp function - one which
            happens to return expressions. The definition of nil! contains a
            single call to list, but another macro might invoke a whole
            subprogram to generate its expansion.
        </para>
        <para>
            Being able to change what the compiler sees is almost like being
            able to rewrite it. We can add any construct to the language that
            we can define by transformation into existing constructs.
        </para>
    </section>
    <section xml:id="backquote" xreflabel="Backquote">
        <title>Backquote</title>
        <para>
            Backquote is a special version of quote which can be used to
            create templates for Lisp expressions. One of the most common uses
            of backquote is in macro definitions.
        </para>
        <para>
            The backquote character, `, is so named because it resembles a
            regular quote, ', reversed. When backquote alone is affixed to an
            expression, it behaves just like quote:
            <code>`(a b c)</code>
            is equal to <code>'(a b c)</code>.
        </para>
        <para>
            Backquote becomes useful only when it appears in combination
            with comma, ,, and comma-at, ,. If backquote makes a template,
            comma makes a slot within a template. A backquoted list is
            equivalent to a call to list with the elements quoted. That is,
            <code>`(a b c)</code>
            is equal to <code>(list 'a 'b 'c)</code>.
        </para>
        <para>
            Within the scope of a backquote, a comma tells Lisp: "turn off
            the quoting." When a comma appears before one of the elements of
            the list, it has the effect of cancelling out the quote that would
            have been put there.
            So
            <code>`(a ,b c ,d)</code>
            is equal to <code>(list 'a b 'c d)</code>.
        </para>
        <para>Instead of the symbol b, its value is inserted into the
            resulting list. Commas work no matter how deeply they appear within
            a nested list,
        </para>
        <programlisting><![CDATA[
> (setq a 1 b 2 c 3)
3
> `(a ,b c)
(A 2 C)
> `(a (,b c))
(A (2 C))]]>
        </programlisting>
        <para>and they may even appear within quotes, or within quoted
            sublists:
        </para>
        <programlisting><![CDATA[
> `(a b ,c (',(+ a b c)) (+ a b) 'c '((,a ,b)))
(A B 3 ('6) (+ A B) 'C '((1 2)))]]>
        </programlisting>
        <para>
            One comma counteracts the effect of one backquote, so commas
            must match backquotes. Say that a comma is surrounded by a
            particular operator if the operator is prepended to the comma, or
            prepended to an expression which contains it. In `<code>(,a ,(b `,c)))</code>,
            for example, the last comma is surrounded by one comma and two
            backquotes. The general rule is: a comma surrounded by n commas
            must be surrounded by at least n+1 backquotes. An obvious corollary
            is that commas may not appear outside of a backquoted expression.
            Backquotes and commas can be nested, so long as they obey the rule
            above. Any of the following expressions would generate an error if
            typed into the toplevel:
        </para>
        <programlisting><![CDATA[
,x `(a ,,b c) `(a ,(b ,c) d) `(,,`a)]]>
        </programlisting>
        <para>
            Nested backquotes are only likely to be needed in macro-defining
            macros. Both topics are discussed in Chapter 16.
        </para>
        <para>
            Backquote is usually used for making lists.
            <footnote>
                <para>
                    Backquote can also be used to create vectors,
                    but this is rarely done in macro definitions.
                </para>
            </footnote>
            Any list generated
            by backquote can also be generated by using list and regular
            quotes. The advantage of backquote is just that it makes
            expressions easier to read, because a backquoted expression
            resembles the expression it will produce. In the previous section
            we defined <function>nil!</function> as:
        </para>
        <programlisting><![CDATA[
(defmacro nil! (var)
  (list 'setq var nil))]]>
        </programlisting>
        <para>
            With backquote the same macro can be defined as:
        </para>
        <programlisting><![CDATA[
(defmacro nil! (var)
  `(setq ,var nil))]]>
        </programlisting>
        <para>which in this case is not all that different. The longer the
            macro definition, however, the more important it is to use
            backquote. <xref linkend="macro-defined-with-and-without-backquote"/>
            contains two possible definitions of <function>nif</function>, a
            macro which does a three-way numeric if.
            <footnote>
                <para>
                    This macro is defined a little oddly to avoid using gensyms.
                    A better definition is given on page 150.
                </para>
            </footnote>
        </para>
        <para>The first argument should evaluate to a number. Then the second,
            third, or fourth argument is evaluated, depending on whether the
            first was positive, zero, or negative:
        </para>
        <programlisting><![CDATA[
> (mapcar #'(lambda (x)
(nif x 'p 'z 'n))
'(0 2.5 -8))
(Z P N)]]>
        </programlisting>
        <figure xml:id="macro-defined-with-and-without-backquote">
            <title>A macro defined with and without backquote.</title>
        <para>With backquote:</para>
        <programlisting><![CDATA[
(defmacro nif (expr pos zero neg)
  `(case (truncate (signum ,expr))
     (1 ,pos)
     (0 ,zero)
     (-1 ,neg)))]]>
        </programlisting>
        <para>Without backquote:</para>
        <programlisting><![CDATA[
(defmacro nif (expr pos zero neg)
  (list 'case
        (list 'truncate (list 'signum expr))
        (list 1 pos)
        (list 0 zero)
        (list -1 neg)))]]>
        </programlisting>
        </figure>
        <!--<a name="IDX28" id="IDX28"></a>-->
        <para>
            The two definitions in <xref linkend="macro-defined-with-and-without-backquote"/>
            define the same macro, but the first uses backquote, while the second builds
            its expansion by
            explicit calls to list. From the first definition it's easy to see
            that <code>(nif x 'p 'z 'n)</code>, for example, expands into
        </para>
        <programlisting><![CDATA[
(case (truncate (signum x))
  (1 'p)
  (0 'z)
  (-1 'n))]]>
        </programlisting>
        <para>because the body of the macro definition looks just like the
            expansion it generates. To understand the second version, without
            backquote, you have to trace in your head the building of the
            expansion.
        </para>
        <para>
            Comma-at, ,@, is a variant of comma. It behaves like comma, with
            one difference: instead of merely inserting the value of the
            expression to which it is affixed, as comma does, comma-at splices
            it. Splicing can be thought of as inserting while removing the
            outermost level of parentheses:
        </para>
        <programlisting><![CDATA[
> (setq b '(1 2 3))
(1 2 3)
> `(a ,b c)
(A (1 2 3) C)
> `(a ,@b c)
(A 1 2 3 C)]]>
        </programlisting>
        <para>
            The comma causes the list
            <code>(1 2 3)</code>
            to be inserted in place of b,
            while the comma-at causes the elements of the list to be inserted
            there. There are some additional restrictions on the use of
            comma-at:
        </para>
        <orderedlist>
            <listitem>
                <para>
                    In order for its argument to be spliced, comma-at must occur
                    within a sequence. It's an error to say something like
                    <code>`,@b</code>
                    because
                    there is nowhere to splice the value of b.
                </para>
            </listitem>
            <listitem>
                <para>
                    The object to be spliced must be a list, unless it occurs last.
                    The expression
                    <code>`(a ,@1)</code>
                    will evaluate to
                    <code>(a . 1)</code>, but attempting to
                    splice an atom into the middle of a list, as in
                    <code>`(a ,@1 b)</code>, will cause an error.
                </para>
            </listitem>
        </orderedlist>
        <para>Comma-at tends to be used in macros which take an indeterminate
            number of arguments and pass them on to functions or macros which
            also take an indeterminate number of arguments. This situation
            commonly arises when implementing implicit blocks. Common Lisp has
            several operators for grouping code into blocks, including
            <function>block</function>, <function>tagbody</function>,
            and <function>progn</function>. These operators rarely appear directly in
            source code; they are more often implicit - that is, hidden by
            macros.
        </para>
        <para>
            An implicit block occurs in any built-in macro which can have a
            body of expressions. Both let and cond provide implicit progn, for
            example. The simplest built-in macro to do so is probably when:
        </para>
        <programlisting><![CDATA[
(when (eligible obj)
  (do-this)
  (do-that)
  obj)]]>
        </programlisting>
        <para>
            If
            <code>(eligible obj)</code>
            returns true, the remaining expressions will
            be evaluated, and the when expression as a whole will return the
            value of the last. As an example of the use of comma-at, here is
            one possible definition for when:
        </para>
        <programlisting><![CDATA[
(defmacro our-when (test &amp;body body)
  `(if ,test
       (progn
         ,@body)))]]>
        </programlisting>
        <para>
            This definition uses an &amp;body parameter (identical to
            <code>&amp;rest</code> except for its effect on pretty-printing) to take in an
            arbitrary number of arguments, and a comma-at to splice them into a
            <function>progn</function> expression. In the macroexpansion of the call above, the
            three expressions in the body will appear within a single
            progn:
        </para>
        <programlisting><![CDATA[
(if (eligible obj)
    (progn (do-this)
           (do-that)
           obj))]]>
        </programlisting>
        <para>
            Most macros for iteration splice their arguments in a similar
            way.
        </para>
        <para>
            The effect of comma-at can be achieved without using backquote.
            The expression <code>`(a ,@b c)</code>
            is equal to <code>(cons 'a (append b (list'c)))</code>,
            for example. Comma-at exists only to make such
            expression-generating expressions more readable.
        </para>
        <para>
            Macro definitions (usually) generate lists. Although macro
            expansions could be built with the function list, backquote
            list-templates make the task much easier. A macro defined with
            defmacroand backquote will superficially resemble a function
            defined with <function>defun</function>. So long as you are not misled by the
            similarity, backquote makes macro definitions both easier to write
            and easier to read.
        </para>
        <para>
            Backquote is so often used in macro definitions that people
            sometimes think of backquote as part of defmacro. The last thing to
            remember about backquote is that it has a life of its own, separate
            from its role in macros. You can use backquote anywhere sequences
            need to be built:
        </para>
        <programlisting><![CDATA[
(defun greet (name)
  `(hello ,name))]]>
        </programlisting>
    </section>
    <section xml:id="defining-simple-macros" xreflabel="Defining Simple Macros">
        <title>Defining Simple Macros</title>
        <para>
            In programming, the best way to learn is often to begin
            experimenting as soon as possible. A full theoretical understanding
            can come later. Accordingly, this section presents a way to start
            writing macros immediately. It works only for a narrow range of
            cases, but where applicable it can be applied quite mechanically.
            (If you've written macros before, you may want to skip this
            section.)
        </para>
        <para>
            As an example, we consider how to write a variant of the the
            built-in Common Lisp function member. By default member uses eql to
            test for equality. If you want to test for membership using eq, you
            have to say so explicitly:
        </para>
        <programlisting><![CDATA[
(member x choices :test #'eq)]]>
        </programlisting>
        <para>
            If we did this a lot, we might want to write a variant of member
            which always used eq. Some earlier dialects of Lisp had such a
            function, called memq:
            <code>(memq x choices)</code>
            Ordinarily one would define
            <function>memq</function>
            as an inline function, but for the sake of example we will
            reincarnate it as a macro.
        </para>
        <figure xml:id="diagram-used-in-writing-memq">
            <title>Diagram used in writing <function>memq</function>.</title>
            <programlisting><![CDATA[
call: (memq x choices)
expansion: (member x choices :test #'eq)]]>
            </programlisting>
        </figure>
        <!--<a name="IDX29" id="IDX29"></a>-->
        <para>
            The method: Begin with a typical call to the macro you want to
            define. Write it down on a piece of paper, and below it write down
            the expression into which it ought to expand.
            <xref linkend="diagram-used-in-writing-memq"/> shows two
            such expressions. From the macro call, construct the parameter list
            for your macro, making up some parameter name for each of the
            arguments. In this case there are two arguments, so we'll have two
            parameters, and call them obj and lst:
        </para>
        <programlisting><![CDATA[
(defmacro memq (obj lst)]]>
        </programlisting>
        <para>
            Now go back to the two expressions you wrote down. For each
            argument in the macro call, draw a line connecting it with the
            place it appears in the expansion below.
            In <xref linkend="diagram-used-in-writing-memq"/> there are
            two parallel lines. To write the body of the macro, turn your
            attention to the expansion. Start the body with a backquote. Now,
            begin reading the expansion expression by expression. Wherever you
            find a parenthesis that isn't part of an argument in the macro
            call, put one in the macro definition. So following the backquote
            will be a left parenthesis. For each expression in the
            expansion
        </para>
        <orderedlist>
            <listitem>
                <para>
                    If there is no line connecting it with the macro call, then
                    write down the expression itself.
                </para>
            </listitem>
            <listitem>
                <para>
                    If there is a connection to one of the arguments in the macro
                    call, write down the symbol which occurs in the corresponding
                    position in the macro parameter list, preceded by a comma.
                </para>
            </listitem>
        </orderedlist>
        <para>
            There is no connection to the first element, member, so we use
            member itself:
        </para>
        <programlisting><![CDATA[
(defmacro memq (obj lst)
  `(member]]>
        </programlisting>
        <para>
            However, x has a line leading to the first argument in the
            source expression, so we use in the macro body the first parameter,
            with a comma:
        </para>
        <programlisting><![CDATA[
(defmacro memq (obj lst)
  `(member ,obj]]>
        </programlisting>
        <para>Continuing in this way, the completed macro definition is:</para>
        <programlisting><![CDATA[
(defmacro memq (obj lst)
  `(member ,obj ,lst :test #'eq))]]>
        </programlisting>
        <figure xml:id="diagram-used-in-writing-while">
            <title>Diagram used in writing <function>while</function>.</title>
            <programlisting><![CDATA[
(while hungry
  (stare-intently)
  (meow)
  (rub-against-legs))

(do ()
    ((not hungry))
  (stare-intently)
  (meow)
  (rub-against-legs))]]>
        </programlisting>
        </figure>
        <!--<a name="IDX30" id="IDX30"></a>-->
        <para>
            So far, we can only write macros which take a fixed number of
            arguments. Now suppose we want to write a macro while, which will
            take a test expression and some body of code, and loop through the
            code as long as the test expression returns true. 
            <xref linkend="diagram-used-in-writing-while"/>
            contains an example of a while loop describing the behavior of a
            cat.
        </para>
        <para>
            To write such a macro, we have to modify our technique slightly.
            As before, begin by writing down a sample macro call. From that,
            build the parameter list of the macro, but where you want to take
            an indefinite number of arguments, conclude with an &amp;rest or
            &amp;body parameter:
        </para>
        <programlisting><![CDATA[
(defmacro while (test &body body)]]>
        </programlisting>
        <para>
            Now write the desired expansion below the macro call, and as
            before draw lines connecting the arguments in the macro call to
            their position in the expansion. However, when you have a sequence
            of arguments which are going to be sucked into a single &amp;rest
            or &amp;body parameter, treat them as a group, drawing a single
            line for the whole sequence.
            <xref linkend="diagram-used-in-writing-while"/> shows the resulting
            diagram.
        </para>
        <para>
            To write the body of the macro definition, proceed as before
            along the expansion. As well as the two previous rules, we need one
            more:
        </para>
        <para>
            If there is a connection from a series of expressions in the
            expansion to a series of the arguments in the macro call, write
            down the corresponding &amp;rest or &amp;body parameter, preceded
            by a comma-at. So the resulting macro definition will be:
        </para>
        <programlisting><![CDATA[
(defmacro while (test &body body)
  `(do ()
       ((not ,test))
     ,@body))]]>
        </programlisting>
        <para>
            To build a macro which can have a body of expressions, some
            parameter has to act as a funnel. Here multiple arguments in the
            macro call are joined together into body, and then broken up again
            when body is spliced into the expansion.
        </para>
        <para>
            The approach described in this section enables us to write the
            simplest macros - those which merely shuffle their parameters.
            Macros can do a lot more than that. Section
            <xref linkend="macros-as-programs"/> will present
            examples where expansions can't be represented as simple backquoted
            lists, and to generate them, macros become programs in their own
            right.
        </para>
    </section>
    <section xml:id="testing-macroexpansion" xreflabel="Testing Macroexpansion">
        <title>Testing Macroexpansion</title>
        <para>Having written a macro, how do we test it? A macro like memq is
            simple enough that one can tell just by looking at it what it will
            do. When writing more complicated macros, we have to be able to
            check that they are being expanded correctly.
        </para>
        <para>
            <xref linkend="macro-and-two-depths-of-expansion"/>
            shows a macro definition and two ways of looking at
            its expansion. The built-in function macroexpand takes an
            expression and returns its macroexpansion. Sending a macro call to
            macroexpand shows how the macro call will finally be expanded
            before being evaluated, but a complete expansion is not always what
            you want in order to test a macro. When the macro in question
            relies on other macros, they too will be expanded, so a complete
            macroexpansion can sometimes be difficult to read.
        </para>
        <para>
            From the first expression shown in
            <xref linkend="macro-and-two-depths-of-expansion"/>, it's hard to tell
            whether or not while is expanding as intended, because the built-in
            do macro gets expanded, as well as the <function>prog</function> macro into which it
            expands. What we need is a way of seeing the result after only one
            step of expansion. This is the purpose of the built-in function
            <function>macroexpand-1</function>, shown in the second example;
            <function>macroexpand-1</function> stops
            after just one step, even if the expansion is still a macro
            call.
        </para>
        <para>When we want to look at the expansion of a macro call, it will
            be a nuisance always to have to type
        </para>
        <programlisting>
            (pprint (macroexpand-1 '(or x y)))
        </programlisting>
        <para>
            <xref linkend="macro-for-testing-macroexpansion"/> defines a
            new macro which allows us to say instead.
        </para>
        <programlisting><![CDATA[
(mac (or x y))]]>
        </programlisting>
        <figure xml:id="macro-and-two-depths-of-expansion">
            <title>A macro and two depths of expansion.</title>
            <programlisting><![CDATA[
> (defmacro while (test &body body)
    `(do ()
        ((not ,test))
        ,@body))
WHILE
> (pprint (macroexpand '(while (able) (laugh))))
(BLOCK NIL
(LET NIL
(TAGBODY
#:G61
(IF (NOT (ABLE)) (RETURN NIL))
(LAUGH)
(GO #:G61))))
T
> (pprint (macroexpand-1 '(while (able) (laugh))))
(DO NIL
((NOT (ABLE)))
(LAUGH))
T]]>
            </programlisting>
        </figure>
        <!--<a name="IDX31" id="IDX31"></a>-->
        <figure xml:id="macro-for-testing-macroexpansion">
            <title>A macro for testing macroexpansion.</title>
            <programlisting><![CDATA[
(defmacro mac (expr)
  `(pprint (macroexpand-1 ',expr)))]]>
            </programlisting>
        </figure>
        <!-- <a name="IDX32" id="IDX32"></a> -->
        <para>
            Typically you debug functions by calling them, and macros by
            expanding them. But since a macro call involves two layers of
            computation, there are two points where things can go wrong. If a
            macro is misbehaving, most of the time you will be able to tell
            what's wrong just by looking at the expansion. Sometimes, though,
            the expansion will look fine and you'll want to evaluate it to see
            where the problems arise. If the expansion contains free variables,
            you may want to set some variables first. In some systems, you will
            be able to copy the expansion and paste it into the toplevel, or
            select it and choose eval from a menu. In the worst case you can
            set a variable to the list returned by <function>macroexpand-1</function>,
            then call eval on it:
        </para>
        <programlisting><![CDATA[
> (setq exp (macroexpand-1 '(memq 'a '(a b c))))
(MEMBER (QUOTE A) (QUOTE (A B C)) :TEST (FUNCTION EQ))
> (eval exp)
(A B C)]]>
        </programlisting>
        <para>
            Finally, macroexpansion is more than an aid in debugging, it's
            also a way of learning how to write macros. Common Lisp has over a
            hundred macros built-in, some of them quite complex. By looking at
            the expansions of these macros you will often be able to see how
            they were written.
        </para>
    </section>
    <section xml:id="desctructuring-in-parameter-lists">
        <title>Destructuring in Parameter Lists</title>
        <para>
            Destructuring is a generalization of the sort of assignment 3
            done by function calls. If you define a function of several
            arguments
        </para>
        <programlisting><![CDATA[
(defun foo (x y z)
  (+ x y z))]]>
        </programlisting>
        <para>then when the function is called</para>
        <programlisting><![CDATA[
(foo 1 2 3)]]>
        </programlisting>
        <para>the parameters of the function are assigned arguments in the
            call according to their position: x to 1, y to 2, and z to 3.
            Destructuring describes the situation where this sort of positional
            assignment is done for arbitrary list structures, as well as flat
            lists like <code>(x y z)</code>.
        </para>
        <para>
            The Common Lisp
            <function>destructuring-bind</function>
            macro (new in CLTL2) takes a
            pattern, an argument evaluating to a list, and a body of
            expressions, and evaluates the expressions with the parameters in
            the pattern bound to the corresponding elements of the list:
        </para>
        <programlisting><![CDATA[
> (destructuring-bind (x (y) . z) '(a (b) c d)
(list x y z))
(A B (C D))]]>
        </programlisting>
        <para>This new operator and others like it form the subject of Chapter
            18.
        </para>
        <para>
            Destructuring is also possible in macro parameter lists. The
            Common Lisp defmacro allows parameter lists to be arbitrary list
            structures. When a macro call is expanded, components of the call
            will be assigned to the parameters as if by
            <function>destructuring-bind</function>. The
            built-in
            <function>dolist</function>
            macro takes advantage of such parameter list
            destructuring. In a call like:
        </para>
        <para>
            Destructuring is usually seen in operators which create
            bindings, rather than do assignments. However, conceptually
            destructuring is a way of assigning values, and would work just as
            well for existing variables as for new ones. That is, there is
            nothing to stop you from writing a destructuring <function>setq</function>.
        </para>
        <programlisting><![CDATA[
(dolist (x '(a b c))
  (print x))]]>
        </programlisting>
        <para>the expansion function must pluck x and
            <code>'(a b c)</code>
            from within the
            list given as the first argument. That can be done implicitly by
            giving dolist the appropriate parameter list:
            <footnote>
                <para>
                    This version is written in this strange way to avoid
                    using gensyms, which are not introduced till later.
                </para>
            </footnote>
        </para>
        <programlisting><![CDATA[
(defmacro our-dolist ((var list &optional result) &body body)
  `(progn
     (mapc #'(lambda (,var) ,@body)
           ,list)
     (let ((,var nil))
       ,result)))]]>
        </programlisting>
        <para>In Common Lisp, macros like dolist usually enclose within a list
            the arguments not part of the body. Because it takes an optional
            result argument, dolist must enclose its first arguments in a
            distinct list anyway. But even if the extra list structure were not
            necessary, it would make calls to dolist easier to read. Suppose we
            want to define a macro when-bind, like when except that it binds
            some variable to the value returned by the test expression. This
            macro may be best implemented with a nested parameter list:
        </para>
        <programlisting><![CDATA[
(defmacro when-bind ((var expr) &amp;body body)
  `(let ((,var ,expr))
     (when ,var
       ,@body)))]]>
        </programlisting>
        <para>and called as follows:</para>
        <programlisting><![CDATA[
(when-bind (input (get-user-input))
           (process input))]]>
        </programlisting>
        <para>instead of:</para>
        <programlisting><![CDATA[
(let ((input (get-user-input)))
  (when input
    (process input)))]]>
        </programlisting>
        <para>Used sparingly, parameter list destructuring can result in
            clearer code. At a minimum, it can be used in macros like when-bind
            and dolist, which take two or more arguments followed by a body of
            expressions.
        </para>
        <figure xml:id="sketch-of-defmacro">
            <title>A sketch of defmacro.</title>
            <programlisting><![CDATA[
(defmacro our-expander (name) `(get ,name 'expander))

(defmacro our-defmacro (name parms &amp;body body)
  (let ((g (gensym)))
    `(progn
       (setf (our-expander ',name)
             #'(lambda (,g)
                 (block ,name
                   (destructuring-bind ,parms (cdr ,g)
                     ,@body))))
       ',name)))

(defun our-macroexpand-1 (expr)
  (if (and (consp expr) (our-expander (car expr)))
      (funcall (our-expander (car expr)) expr)
    expr))]]>
            </programlisting>
        </figure>
        <!-- <a name="IDX33" id="IDX33"></a> -->
    </section>
    <section xml:id="model-of-macros" xreflabel="A Model of Macros">
        <title>A Model of Macros</title>
        <para>
            A formal description of what macros dowouldbe long and
            confusing. Experienced programmers do not carry such a description
            in their heads anyway. It's more convenient to remember what
            defmacro does by imagining how it would be defined.
        </para>
        <para>
            There is a long tradition of such explanations in Lisp. The Lisp
            1.5 Programmer's Manual, first published in 1962, gives for
            reference a definition of eval written in Lisp.
            Since <function>defmacro</function> is
            itself a macro, we can give it the same treatment, as in
            <xref linkend="sketch-of-defmacro"/> .
            This definition uses several techniques which haven't been
            covered yet, so some readers may want to refer to it later.
        </para>
        <para>
            The definition in <xref linkend="sketch-of-defmacro"/>
            gives a fairly accurate impression
            of what macros do, but like any sketch it is incomplete. It
            wouldn't handle the &amp;whole keyword properly. And what
            <function>defmacro</function>
            really stores as the macro-function of its first argument is a
            function of two arguments: the macro call, and the lexical
            environment in which it occurs. However, these features are used
            only by the most esoteric macros. If you worked on the assumption
            that macros were implemented as in <xref linkend="sketch-of-defmacro"/>,
            you would hardly
            ever go wrong. Every macro defined in this book would work, for
            example. The definition in <xref linkend="sketch-of-defmacro"/>
            yields an expansion function
            which is a sharp-quoted lambda-expression. That should make it a
            closure: any free symbols in the macro definition should refer to
            variables in the environment where the <function>defmacro</function>
            occurred. So it should be possible to say this:
        </para>
        <programlisting><![CDATA[
(let ((op 'setq))
  (defmacro our-setq (var val)
    (list op var val)))]]>
        </programlisting>
        <para>
            As of CLTL2, it is. But in CLTL1, macro expanders were defined
            in the null lexical environment,
            <footnote>
                <para>
                    For an example of macro where this distinction matters,
                    see the note on page 393.
                </para>
            </footnote>
            so in some old implementations this
            definition of
            <function>our-setq</function>
            will not work.
        </para>
    </section>
    <section xml:id="macros-as-programs" xreflabel="Macros as Programs">
        <title>Macros as Programs</title>
        <para>
            A macro definition need not be just a backquoted list. A macro
            is a function which transforms one sort of expression into another.
            This function can call list to generate its result, but can just as
            well invoke a whole subprogram consisting of hundreds of lines of
            code.
        </para>
        <para>
            Section <xref linkend="defining-simple-macros"/>
            gave an easy way of writing macros. Using this
            technique we can write macros whose expansions contain the same
            subexpressions as appear in the macro call. Unfortunately, only the
            simplest macros meet this condition. As a more complicated example,
            consider the built-in macro do. It isn't possible to write do as a
            macro which simply shuffles its parameters. The expansion has to
            build complex expressions which never appear in the macro call.
        </para>
        <para>
            The more general approach to writing macros is to think about
            the sort of expression you want to be able to use, what you want it
            to expand into, and then write the program that will transform the
            first form into the second. Try expanding an example by hand, then
            look at what happens when one form is transformed into another. By
            working from examples you can get an idea of what will be required
            of your proposed macro.
        </para>
        <programlisting><![CDATA[
(do ((w 3)
     (x 1 (1+ x))
     (y 2 (1+ y))
     (z))
    ((> x 10) (princ z) y)
  (princ x)
  (princ y))]]>
        </programlisting>
        <para>should expand into something like</para>
        <figure xml:id="desired-expansion-of-do">
            <title>Desired expansion of do.</title>
            <programlisting><![CDATA[
(prog ((w 3) (x 1) (y 2) (z nil))
      foo
      (if (> x 10)
          (return (progn (princ z) y)))
      (princ x)
      (princ y)
      (psetq x (1+ x) y (1+ y))
      (go foo))]]>
            </programlisting>
        </figure>
        <!-- <a name="IDX34" id="IDX34"></a> -->
        <para>
            <xref linkend="desired-expansion-of-do"/>
            shows an instance of do, and the expression into
            which it should expand. Doing expansions by hand is a good way to
            clarify your ideas about how a macro should work. For example, it
            may not be obvious until one tries writing the expansion that the
            local variables will have to be updated using <function>psetq</function>.
        </para>
        <para>
            The built-in macro
            <function>psetq</function>
            (named for "parallel setq") behaves
            like <function>setq</function>, except that all its (even-numbered)
            arguments will be
            evaluated before any of the assignments are made. If an ordinary
            <function>setq</function>
            has more than two arguments,
            then the new value of the first
            argument is visible during the evaluation of the fourth:
        </para>
        <programlisting><![CDATA[
> (let ((a 1))
    (setq a 2 b a)
    (list a b))
(2 2)]]>
        </programlisting>
        <para>
            Here, because a is set first, b gets its new value, 2. A
            <function>psetq</function>
            is supposed to behave as if its arguments were assigned in
            parallel:
        </para>
        <programlisting><![CDATA[
> (let ((a 1))
    (psetq a 2 b a)
    (list a b))
(2 1)]]>
        </programlisting>
        <para>
            So here b gets the old value of a. The
            <function>psetq</function> macro is provided
            especially to support macros like
            <function>do</function>, which need to evaluate some
            of their arguments in parallel. (Had we used <function>setq</function>,
            we would have been defining <function>do*</function> instead.)
        </para>
        <para>
            On looking at the expansion, it is also clear that we can't
            really use foo as the loop label. What if foo is also used as a
            loop label within the body of the <function>do</function>?
            Chapter 9 will deal with this
            problem in detail; for now, suffice it to say that instead of using
            foo, the macroexpansion must use a special anonymous symbol
            returned by the function <function>gensym</function>.
        </para>
        <figure xml:id="implementing-do">
            <title>Implementing <function>do</function>.</title>
            <programlisting><![CDATA[
(defmacro our-do (bindforms (test &rest result) &body body)
  (let ((label (gensym)))
    `(prog ,(make-initforms bindforms)
           ,label
           (if ,test
               (return (progn ,@result)))
           ,@body
           (psetq ,@(make-stepforms bindforms))
           (go ,label))))

(defun make-initforms (bindforms)
  (mapcar #'(lambda (b)
              (if (consp b)
                  (list (car b) (cadr b))
                (list b nil)))
          bindforms))

(defun make-stepforms (bindforms)
  (mapcan #'(lambda (b)
              (if (and (consp b) (third b))
                  (list (car b) (third b))
                nil))
          bindforms))]]>
        </programlisting></figure>
        <!-- <a name="IDX35" id="IDX35"></a> -->
        <para>
            In order to write <function>do</function>, we consider what it would take to
            transform the first expression in <xref linkend="desired-expansion-of-do"/>
            into the second. To
            perform such a transformation, we need to do more than get the
            macro parameters into the right positions in some backquoted list.
            The initial prog has to be followed by a list of symbols and their
            initial bindings, which must be extracted from the second argument
            passed to the do. The function <function>make-initforms</function> in
            <xref linkend="implementing-do"/> will
            return such a list. We also have to build a list of arguments for
            the psetq, but this case is more complicated because not all the
            symbols should be updated. In <xref linkend="implementing-do"/>,
            <function>make-stepforms</function> returns
            arguments for the <function>psetq</function>.
            With these two functions, the rest of the definition becomes fairly straightforward.
        </para>
        <para>
            The code in <xref linkend="implementing-do"/> isn't exactly the way
            do would be written
            in a real implementation. To emphasize the computation done during
            expansion,
            <function>make-initforms</function>
            and
            <function>make-stepforms</function>
            have been broken out
            as separate functions. In the future, such code will usually be
            left within the defmacroexpression.
        </para>
        <para>With the definition of this macro, we begin to see what macros
            can do. A macro has full access to Lisp to build an expansion. The
            code used to generate the expansion may be a program in its own
            right.
        </para>
    </section>
    <section xml:id="macro-style" xreflabel="Macro Style">
        <title>Macro Style</title>
        <para>
            Good style means something different for macros. Style matters
            when code is either read by people or evaluated by Lisp. With
            macros, both of these activities take place under slightly unusual
            circumstances.
        </para>
        <para>
            There are two different kinds of code associated with a macro
            definition: expander code, the code used by the macro to generate
            its expansion, and expansion code, which appears in the expansion
            itself. The principles of style are different for each. For
            programs in general, to have good style is to be clear and
            efficient. These principles are bent in opposite directions by the
            two types of macro code: expander code can favor clarity over
            efficiency, and expansion code can favor efficiency over
            clarity.
        </para>
        <para>
            It's in compiled code that efficiency counts most, and in
            compiled code the macro calls have already been expanded. If the
            expander code was efficient, it made compilation go slightly
            faster, but it won't make any difference in how well the program
            runs. Since the expansion of macro calls tends to be only a small
            part of the work done by a compiler, macros which expand
            efficiently can't usually make much of a difference even in the
            compilation speed. So most of the time you can safely write
            expander code the way you would write a quick, first version of a
            program. If the expander code does unnecessary work or conses a
            lot, so what? Your time is better spent improving other parts of
            the program. Certainly if there's a choice between clarity and
            speed in expander code, clarity should prevail. Macro definitions
            are generally harder to read than function definitions, because
            they contain a mix of expressions evaluated at two different times.
            If this confusion can be reduced at the expense of efficiency in
            the expander code, it's a bargain.
        </para>
        <para>
            For example, suppose that we wanted to define a version of and
            as a macro. Since
            <code>(and a b c)</code>
            is equivalent to <code>(if a (if b c))</code>, we
            can write and in terms of if as in the first definition in
            <xref linkend="two-macors-equivalent-to-and"/>.
            According to the standards by which we judge ordinary code,
            our-and is badly written. The expander code is recursive, and on
            each recursion finds the length of successive cdrs of the same
            list. If this code were going to be evaluated at runtime, it would
            be better to define this macro as in <code>our-andb</code>,
            which generates the
            same expansion with no wasted effort. However, as a macro
            definition our-and is just as good, if not better. It may be
            inefficient in calling length on each recursion, but its
            organization shows more clearly the way in which the expansion
            depends on the number of conjuncts.
        </para>
        <figure xml:id="two-macors-equivalent-to-and">
            <title>Two macros equivalent to and.</title>
            <programlisting><![CDATA[
(defmacro our-and (&rest args)
  (case (length args)
    (0 t)
    (1 (car args))
    (t `(if ,(car args)
            (our-and ,@(cdr args))))))

(defmacro our-andb (&rest args)
  (if (null args)
      t
    (labels ((expander (rest)
                       (if (cdr rest)
                           `(if ,(car rest)
                                ,(expander (cdr rest)))
                         (car rest))))
      (expander args))))]]>
            </programlisting>
        </figure>
        <!-- <a name="IDX36" id="IDX36"></a> -->
        <para>
            As always, there are exceptions. In Lisp, the distinction
            between compile-time and runtime is an artificial one, so any rule
            which depends upon it is likewise artificial. In some programs,
            compile-time is runtime. If you're writing a program whose main
            purpose is transformation and which uses macros to do it, then
            everything changes: the expander code becomes your program, and the
            expansion its output. Of course under such circumstances expander
            code should be written with efficiency in mind. However, it's safe
            to say that most expander code (a) only affects the speed of
            compilation, and (b) doesn't affect it very much - meaning that
            clarity should nearly always come first.
        </para>
        <para>
            With expansion code, it's just the opposite. Clarity matters
            less for macro expansions because they are rarely looked at,
            especially by other people. The forbidden goto is not entirely
            forbidden in expansions, and the disparaged setq not quite so
            disparaged.
        </para>
        <para>
            Proponents of structured programming disliked goto for what it
            did to source code. It was not machine language jump instructions
            that they considered harmful - so long as they were hidden by more
            abstract constructs in source code. Gotos are condemned in Lisp
            precisely because it's so easy to hide them: you can use do
            instead, and if you didn't have do, you could write it. Of course,
            if we're going to build new abstractions on top of goto, the goto
            is going to have to exist somewhere. Thus it is not necessarily bad
            style to use go in the definition of a new macro, if it can't be
            written in terms of some existing macro.
        </para>
        <para>
            Similarly,
            <function>setq</function>
            is frowned upon because
            it makes it hard to see
            where a given variable gets its value. However, a macroexpansion is
            not going to be read by many people, so there is usually little
            harm in using
            <function>setq</function>
            on variables
            created within the macroexpansion.
            If you look at expansions of some of the built-in macros, you'll
            see quite a lot of <function>setq</function>s.
        </para>
        <para>
            Several circumstances can make clarity more important in
            expansion code. If you're writing a complicated macro, you may end
            up reading the expansions after all, at least while you're
            debugging it. Also, in simple macros, only a backquote separates
            expander code from expansion code, so if such macros generate ugly
            expansions, the ugliness will be all too visible in your source
            code. However, even when the clarity of expansion code becomes an
            issue, efficiency should still predominate. Efficiency is important
            in most runtime code. Two things make it especially so for macro
            expansions: their ubiquity and their invisibility.
        </para>
        <para>
            Macros are often used to implement general-purpose utilities,
            which are then called everywhere in a program. Something used so
            often can't afford to be inefficient. What looks like a harmless
            little macro could, after the expansion of all the calls to it,
            amount to a significant proportion of your program. Such a macro
            should receive more attention than its length would seem to demand.
            Avoid consing especially. A utility which conses unnecessarily can
            ruin the performance of an otherwise efficient program.
        </para>
        <para>
            The other reason to look to the efficiency of expansion code is
            its very invisibility. If a function is badly implemented, it will
            proclaim this fact to you every time you look at its definition.
            Not so with macros. From a macro definition, inefficiency in the
            expansion code may not be evident, which is all the more reason to
            go looking for it.
        </para>
    </section>
    <section xml:id="dependence-on-macros" xreflabel="Dependence on Macros">
        <title>Dependence on Macros</title>
        <para>
            If you redefine a function, other functions which call it will
            automatically get the new version.
            <footnote>
                <para>
                    Except functions compiled inline, which impose the same
                    restrictions on redefinition as macros.
                </para>
            </footnote>
            The same doesn't always hold for
            macros. A macro call which occurs in a function definition gets
            replaced by its expansion when the function is compiled. What if we
            redefine the macro after the calling function has been compiled?
            Since no trace of the original macro call remains, the expansion
            within the function can't be updated. The behavior of the function
            will continue to reflect the old macro definition:
        </para>
        <programlisting><![CDATA[
> (defmacro mac (x) `(1+ ,x))
MAC
> (setq fn (compile nil '(lambda (y) (mac y))))
#<Compiled-Function BF7E7E>
> (defmacro mac (x) `(+ ,x 100))
MAC
> (funcall fn 1)
2]]>
        </programlisting>
        <para>
            Similar problems occur if code which calls some macro is
            compiled before the macro itself is defined. CLTL2 says that "a
            macro definition must be seen by the compiler before the first use
            of the macro." Implementations vary in how they respond to
            violations of this rule. Fortunately it's easy to avoid both types
            of problem. If you adhere to the following two principles, you need
            never worry about stale or nonexistent macro definitions:
        </para>
        <orderedlist>
            <listitem>
                <para>
                    Define macros before functions (or macros) which call them.
                </para>
            </listitem>
            <listitem>
                <para>
                    When a macro is redefined, also recompile all the functions (or
                    macros) which call it - directly or via other macros.
                </para>
            </listitem>
        </orderedlist>
        <para>
            It has been suggested that all the macros in a program be put in
            a separate file, to make it easier to ensure that macro definitions
            are compiled first. That's taking things too far. It would be
            reasonable to put general-purpose macros like while into a separate
            file, but general-purpose utilities ought to be separated from the
            rest of a program anyway, whether they're functions or macros.
        </para>
        <para>
            Some macros are written just for use in one specific part of a
            program, and these should be defined with the code which uses them.
            So long as the definition of each macro appears before any calls to
            it, your programs will compile fine. Collecting together all your
            macros, simply because they're macros, would do nothing but make
            your code harder to read.
        </para>
    </section>
    <section xml:id="macros-from-functions" xreflabel="Macros from Functions">
        <title>Macros from Functions</title>
        <para>This section describes how to transform functions into macros.
            The first step in translating a function into a macro is to ask
            yourself if you really need to do it. Couldn't you just as well
            declare the function inline (p. 26)?
        </para>
        <para>
            There are some legitimate reasons to consider how to translate
            functions into macros, though. When you begin writing macros, it
            sometimes helps to think as if you were writing a function - an
            approach that usually yields macros which aren't quite right, but
            which at least give you something to work from. Another reason to
            look at the relationship between macros and functions is to see how
            they differ. Finally, Lisp programmers sometimes actually want to
            convert functions into macros.
        </para>
        <para>
            The difficulty of translating a function into a macro depends on
            a number of properties of the function. The easiest class to
            translate are the functions which
        </para>
        <orderedlist>
            <listitem>
                <para>Have a body consisting of a single expression.</para>
            </listitem>
            <listitem>
                <para>Have a parameter list consisting only of parameter names.</para>
            </listitem>
            <listitem>
                <para>Create no new variables (except the parameters).</para>
            </listitem>
            <listitem>
                <para>
                    Are not recursive (nor part of a mutually recursive group).
                </para>
            </listitem>
            <listitem>
                <para>
                    Have no parameter which occurs more than once in the body.
                </para>
            </listitem>
            <listitem>
                <para>
                    Have no parameter whose value is used before that of another
                    parameter occurring before it in the parameter list.
                </para>
            </listitem>
            <listitem>
                <para>Contain no free variables.</para>
            </listitem>
        </orderedlist>
        <para>
            One function which meets these criteria is the built-in Common
            Lisp function second, which returns the second element of a list.
            It could be defined:
        </para>
        <programlisting><![CDATA[
(defun second (x) (cadr x))]]>
        </programlisting>
        <para>
            Where a function definition meets all the conditions above, you
            can easily transform it into an equivalent macro definition. Simply
            put a backquote in front of the body and a comma in front of each
            symbol which occurs in the parameter list:
        </para>
        <programlisting><![CDATA[
(defmacro second (x) `(cadr ,x))]]>
        </programlisting>
        <para>
            Of course, the macro can't be called under all the same
            conditions. It can't be given as the first argument to apply or
            funcall, and it should not be called in environments where the
            functions it calls have new local bindings. For ordinary in-line
            calls, though, the macro second should do the same thing as the
            function second.
        </para>
        <para>
            The technique changes slightly when the body has more than one
            expression, because a macro must expand into a single expression.
            So if condition 1 doesn't hold, you have to add a
            <function>progn</function>.
            The function <function>noisy-second</function>:
        </para>
        <programlisting><![CDATA[
(defun noisy-second (x)
  (princ "Someone is taking a cadr!")
  (cadr x))]]>
        </programlisting>
        <para>could be duplicated by the following macro:</para>
        <programlisting><![CDATA[
(defmacro noisy-second (x)
  `(progn
     (princ "Someone is taking a cadr!")
     (cadr ,x)))]]>
        </programlisting>
        <para>
            When the function doesn't meet condition 2 because it has an
            <parameter>&amp;rest</parameter>
            or
            <parameter>&amp;body</parameter>
            parameter, the rules are the same, except
            that the parameter, instead of simply having a comma before it,
            must be spliced into a call to list. Thus
        </para>
        <programlisting><![CDATA[
(defun sum (&rest args)
  (apply #'+ args))]]>
        </programlisting>
        <para>becomes</para>
        <programlisting><![CDATA[
(defmacro sum (&rest args)
  `(apply #'+ (list ,@args)))]]>
        </programlisting>
        <para>which in this case would be better rewritten:</para>
        <programlisting><![CDATA[
(defmacro sum (&rest args)
  `(+ ,@args))]]>
        </programlisting>
        <para>
            When condition 3 doesn't hold - when new variables are created
            within the function body - the rule about the insertion of commas
            must be modified. Instead of putting commas before all symbols in
            the parameter list, we only put them before those which will refer
            to the parameters. For example, in:
        </para>
        <programlisting><![CDATA[
(defun foo (x y z)
  (list x (let ((x y))
            (list x z))))]]>
        </programlisting>
        <para>neither of the last two instances of x will refer to the
            parameter x. The second instance is not evaluated at all, and the
            third instance refers to a new variable established by the let. So
            only the first instance will get a comma:
        </para>
        <programlisting><![CDATA[
(defmacro foo (x y z)
  `(list ,x (let ((x ,y))
              (list x ,z))))]]>
        </programlisting>
        <para>
            Functions can sometimes be transformed into macros when
            conditions 4, 5 and 6 don't hold. However, these topics are treated
            separately in later chapters. The issue of recursion in macros is
            covered in Section 10.4, and the dangers of multiple and misordered
            evaluation in Sections 10.1 and 10.2, respectively.
        </para>
        <para>
            As for condition 7, it is possible to simulate closures with
            macros, using a technique similar to the error described on page
            37. But seeing as this is a low hack, not consonant with the
            genteel tone of this book, we shall not go into details.
        </para>
    </section>
    <section xml:id="symbol-macros" xreflabel="Symbol Macros">
        <title>Symbol Macros</title>
        <para>
            CLTL2 introduced a new kind of macro into Common Lisp, the
            symbol-macro. While a normal macro call looks like a function call,
            a symbol-macro "call" looks like a symbol.
        </para>
        <para>
            Symbol-macros can only be locally defined. The
            <function>symbol-macrolet</function>
            special form can,
            within its body, cause a lone symbol to behave
            like an expression:
        </para>
        <programlisting><![CDATA[
> (symbol-macrolet ((hi (progn (print "Howdy")
                               1)))
    (+ hi 2))
"Howdy"
3]]>
        </programlisting>
        <para>
            The body of the
            <function>symbol-macrolet</function>
            will be evaluated as if every hi
            in argument position had been replaced with
            <code>(progn (print "Howdy") 1)</code>.
        </para>
        <para>
            Conceptually, symbol-macros are like macros that don't take any
            arguments. With no arguments,macros become simply textual
            abbreviations. This is not to say that symbol-macros are useless,
            however. They are used in Chapter 15 (page 205) and Chapter 18
            (page 237), and in the latter instance they are indispensable.
        </para>
    </section>
</chapter>